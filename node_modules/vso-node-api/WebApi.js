// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const buildm = require("./BuildApi");
const chatm = require("./ChatApi");
const contributionsm = require("./ContributionsApi");
const corem = require("./CoreApi");
const dashboardm = require("./DashboardApi");
const delegatedauthorizationm = require("./DelegatedAuthorizationApi");
const extmgmtm = require("./ExtensionManagementApi");
const featuremgmtm = require("./FeatureManagementApi");
const filecontainerm = require("./FileContainerApi");
const gallerym = require("./GalleryApi");
const gitm = require("./GitApi");
const identitiesm = require("./IdentitiesApi");
const locationsm = require("./LocationsApi");
const notificationm = require("./NotificationApi");
const organizationm = require("./OrganizationApi");
const policym = require("./PolicyApi");
const profilem = require("./ProfileApi");
const releasem = require("./ReleaseApi");
const securityrolesm = require("./SecurityRolesApi");
const servicehooksm = require("./ServiceHooksApi");
const taskagentm = require("./TaskAgentApi");
const taskm = require("./TaskApi");
const testm = require("./TestApi");
const tfvcm = require("./TfvcApi");
const workm = require("./WorkApi");
const workitemtrackingm = require("./WorkItemTrackingApi");
const basicm = require("./handlers/basiccreds");
const bearm = require("./handlers/bearertoken");
const ntlmm = require("./handlers/ntlm");
const patm = require("./handlers/personalaccesstoken");
const rm = require("typed-rest-client/RestClient");
const vsom = require("./VsoClient");
const fs = require("fs");
const crypto = require("crypto");
/**
 * Methods to return handler objects (see handlers folder)
 */
function getBasicHandler(username, password) {
    return new basicm.BasicCredentialHandler(username, password);
}
exports.getBasicHandler = getBasicHandler;
function getNtlmHandler(username, password, workstation, domain) {
    return new ntlmm.NtlmCredentialHandler(username, password, workstation, domain);
}
exports.getNtlmHandler = getNtlmHandler;
function getBearerHandler(token) {
    return new bearm.BearerCredentialHandler(token);
}
exports.getBearerHandler = getBearerHandler;
function getPersonalAccessTokenHandler(token) {
    return new patm.PersonalAccessTokenCredentialHandler(token);
}
exports.getPersonalAccessTokenHandler = getPersonalAccessTokenHandler;
function getHandlerFromToken(token) {
    if (token.length === 52) {
        return getPersonalAccessTokenHandler(token);
    }
    else {
        return getBearerHandler(token);
    }
}
exports.getHandlerFromToken = getHandlerFromToken;
// ---------------------------------------------------------------------------
// Factory to return client apis
// When new APIs are added, a method must be added here to instantiate the API
//----------------------------------------------------------------------------
class WebApi {
    /*
     * Factory to return client apis and handlers
     * @param defaultUrl default server url to use when creating new apis from factory methods
     * @param authHandler default authentication credentials to use when creating new apis from factory methods
     */
    constructor(defaultUrl, authHandler, options) {
        this.serverUrl = defaultUrl;
        this.authHandler = authHandler;
        this.options = options || {};
        // try get proxy setting from environment variable set by VSTS-Task-Lib if there is no proxy setting in the options
        if (!this.options.proxy || !this.options.proxy.proxyUrl) {
            if (global['_vsts_task_lib_proxy']) {
                let proxyFromEnv = {
                    proxyUrl: global['_vsts_task_lib_proxy_url'],
                    proxyUsername: global['_vsts_task_lib_proxy_username'],
                    proxyPassword: this._readTaskLibSecrets(global['_vsts_task_lib_proxy_password']),
                    proxyBypassHosts: JSON.parse(global['_vsts_task_lib_proxy_bypass'] || "[]"),
                };
                this.options.proxy = proxyFromEnv;
            }
        }
        // try get cert setting from environment variable set by VSTS-Task-Lib if there is no cert setting in the options
        if (!this.options.cert) {
            if (global['_vsts_task_lib_cert']) {
                let certFromEnv = {
                    caFile: global['_vsts_task_lib_cert_ca'],
                    certFile: global['_vsts_task_lib_cert_clientcert'],
                    keyFile: global['_vsts_task_lib_cert_key'],
                    passphrase: this._readTaskLibSecrets(global['_vsts_task_lib_cert_passphrase']),
                };
                this.options.cert = certFromEnv;
            }
        }
        this.rest = new rm.RestClient('vsts-node-api', null, [this.authHandler], this.options);
        this.vsoClient = new vsom.VsoClient(defaultUrl, this.rest);
    }
    /**
     *  Convenience factory to create with a bearer token.
     * @param defaultServerUrl default server url to use when creating new apis from factory methods
     * @param defaultAuthHandler default authentication credentials to use when creating new apis from factory methods
     */
    static createWithBearerToken(defaultUrl, token, options) {
        let bearerHandler = getBearerHandler(token);
        return new this(defaultUrl, bearerHandler, options);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    let res;
                    res = yield this.rest.get(this.vsoClient.resolveUrl('/_apis/connectionData'));
                    resolve(res.result);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
     * Each factory method can take a serverUrl and a list of handlers
     * if these aren't provided, the default url and auth handler given to the constructor for this class will be used
     */
    getBuildApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new buildm.BuildApi(serverUrl, handlers, this.options);
    }
    /**
     * Each API has a method here to create the client.
     */
    getChatApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new chatm.ChatApi(serverUrl, handlers, this.options);
    }
    getCoreApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new corem.CoreApi(serverUrl, handlers, this.options);
    }
    getContributionsApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new contributionsm.ContributionsApi(serverUrl, handlers, this.options);
    }
    getDashboardApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new dashboardm.DashboardApi(serverUrl, handlers, this.options);
    }
    getDelegatedAuthorizationApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new delegatedauthorizationm.DelegatedAuthorizationApi(serverUrl, handlers, this.options);
    }
    getExtensionManagementApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new extmgmtm.ExtensionManagementApi(serverUrl, handlers, this.options);
    }
    getFeatureManagementApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new featuremgmtm.FeatureManagementApi(serverUrl, handlers, this.options);
    }
    getFileContainerApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new filecontainerm.FileContainerApi(serverUrl, handlers, this.options);
    }
    getGalleryApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new gallerym.GalleryApi(serverUrl, handlers, this.options);
    }
    getGitApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new gitm.GitApi(serverUrl, handlers, this.options);
    }
    getIdentitiesApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new identitiesm.IdentitiesApi(serverUrl, handlers, this.options);
    }
    getLocationsApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new locationsm.LocationsApi(serverUrl, handlers, this.options);
    }
    getNotificationApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new notificationm.NotificationApi(serverUrl, handlers, this.options);
    }
    getOrganizationApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new organizationm.OrganizationApi(serverUrl, handlers, this.options);
    }
    getPolicyApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new policym.PolicyApi(serverUrl, handlers, this.options);
    }
    getProfileApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new profilem.ProfileApi(serverUrl, handlers, this.options);
    }
    getSecurityRolesApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new securityrolesm.SecurityRolesApi(serverUrl, handlers, this.options);
    }
    getServiceHooksApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new servicehooksm.ServiceHooksApi(serverUrl, handlers, this.options);
    }
    getReleaseApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new releasem.ReleaseApi(serverUrl, handlers, this.options);
    }
    getTaskApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new taskm.TaskApi(serverUrl, handlers, this.options);
    }
    getTaskAgentApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new taskagentm.TaskAgentApi(serverUrl, handlers, this.options);
    }
    getTestApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new testm.TestApi(serverUrl, handlers, this.options);
    }
    getTfvcApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new tfvcm.TfvcApi(serverUrl, handlers, this.options);
    }
    getWorkApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new workm.WorkApi(serverUrl, handlers, this.options);
    }
    getWorkItemTrackingApi(serverUrl, handlers) {
        serverUrl = serverUrl || this.serverUrl;
        handlers = handlers || [this.authHandler];
        return new workitemtrackingm.WorkItemTrackingApi(serverUrl, handlers, this.options);
    }
    _readTaskLibSecrets(lookupKey) {
        // the lookupKey should has following format
        // base64encoded<keyFilePath>:base64encoded<encryptedContent>
        if (lookupKey && lookupKey.indexOf(':') > 0) {
            let lookupInfo = lookupKey.split(':', 2);
            // file contains encryption key
            let keyFile = new Buffer(lookupInfo[0], 'base64').toString('utf8');
            let encryptKey = new Buffer(fs.readFileSync(keyFile, 'utf8'), 'base64');
            let encryptedContent = new Buffer(lookupInfo[1], 'base64').toString('utf8');
            let decipher = crypto.createDecipher("aes-256-ctr", encryptKey);
            let decryptedContent = decipher.update(encryptedContent, 'hex', 'utf8');
            decryptedContent += decipher.final('utf8');
            return decryptedContent;
        }
    }
}
exports.WebApi = WebApi;
